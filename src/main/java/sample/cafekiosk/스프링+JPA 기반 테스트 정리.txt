----------------------------------------------------------------------------------

레이어드 아키텍처(Layered Architecture)와 테스트

많이들 사용하는 Spring MVC 패턴이죠 레이어드 아키텍처.

1) Presentation Layer
2) Business Layer
3) Persistence Layer
4) Infrastructure Layer

이런식으로 3-tier 아니면 4-tier로 나눠는데
이때 왜 레이어를 이런식으로 분리하는건지 생각해볼 필요가 있습니다.

결론부터 말하자면 관심사를 분리하기 위해서인데
분리하면 좋은점은 레이어마다 책임질 영역이 정해지게 돼서 ( 당연히 관심사가 책임질 부분임 )
유지보수가 편리해진다는 것입니다.

그럼 이제 통합 테스트가 뭔지 알아봅시다.
여러 모듈이 협력했을때 어떻게 작동하는지 검증하는 테스트인데
모듈이 뭐냐면 기능 1개를 구현해내는데 필요한 단위입니다.
그래서 작게는 클래스 1개가 될 수 있고
여러개 모여야만 하나의 기능을 할 수 도 있기 때문에 여러 클래스를 묶어서 하나의 모듈이라고 부를 수 도 있습니다.

그럼 이제 모듈 A와 모듈 B를 함께 실행시켰다고 해봅시다.
그럼 이거 어떻게 작동하죠
순서대로 AB?
아님 반대로 BA?
아님 전혀 다른 C?

결론은 어떻게 동작할지를 모른다가 답입니다.
그래서 모듈이 여러개라면 어떻게 동작할지를 보장하기 위해 통합 테스트를 진행하는 겁니다.

그래서 단위 테스트만으로는 전체 기능을 보장해줄 수 없어서 통합 테스트도 진행해야함.

그럼 이제 레이어 별로 끊어서 테스트를 해볼건데
각각 단위테스트 관점과 통합 테스트 관점
이 2개의 관점에서 살펴봅시다.

----------------------------------------------------------------------------------

Spring & JPA 훑어보기 / 기본 엔티티 설계

Vue.js는 프레임워크
React는 라이브러리

라이브러리는 내가 작성한 코드가 주체가 됨
프레임워크는 내가 작성한 코드가 주체가 아님

(1) IoC : Inversion of Control
(2) DI : Dependency Injection
(3) AOP : Aspect Oriented Programming

IoC
Java에서 A 객체가 B 객체를 사용하고 싶다고 해봅시다.
그럼 new B()로 생성자로 객체를 생성해서 사용합니다
그런데 생성을 하면 제거까지 A가 해줘야하지 않습니까
이런 생성과 제거를 생명주기라고 하고 이 생명주기의 관리를 A가 굳이 해야하나 싶은 생긱이 든겁니다.
그래서 이 책임을 별도로 분리해서 제 3자가 관리하게 만든거임
정리하자면 A가 해야할 일인 생명주기 관리를 제 3자가 한다고해서 제어의 역전이라고 멋져보이게 이름 붙인겁니다.

그리고 여기서 말하는 제 3자는 컨테이너임
그럼 이제 DI도 알아봅시다.
DI 자체는 IoC와 밀접한 연관이 있습니다.
한마디로 말하자면 제어의 역전이 일어났기 때문에 의존성 주입이 있는거임.

이제 상황을 구체적으로 봅시다.
A 객체가 B 객체의 기능이 필요하다고 하면
제 3자인 컨테이너가 주입해준 객체를 사용하는데 이때 인터페이스 형태로
쉽게 말해 약한 결합으로 주입합니다.

왜냐하면 A 객체가 필요한건 B 객체 자체가 아니라 B 객체의 기능이 필요하기 때문임
그래서 기능을 적어놓은 인터페이스로 주입합니다.

AOP에 대해서도 알아봅시다. 한글로 관점 지향 프로그래밍이라고 부름.
(1) 비즈니스 흐름 ( 트랜잭션 )을 핵심 로직으로 봅니다. ( 핵심적인 관점 )
(2) 로그 로깅, DB 연결하기, git으로 형상 관리 등 보통 핵심 로직 앞뒤에 해주는 보조작업
    쉽게 말해 비즈니스 흐름과 관계없는 부분 ( 부가적인 관점 )

이 부가적인 관점이 코드 상에 흩어져있는데 모아서 분리해낸겁니다.
Java에서는 프로시 패턴을 이용해서 구현합니다.


다음은 JPA에 대해서 알아봅시다. ( Java Persistence API )

ORM( Object-Relational Mapping )이라는 것부터 알아야하는데
Relational DB와 Object-Oriented는 방향이 다릅니다.
객체 지향에서 말하는 상속 관계 같은 것이 없음.

그래서 객체 지향으로 개발을 해도
관계형 DB에 넣을때는 데이터 중심으로 구현되는 관계형 DB에
객체를 필드별로 분리해서 맵핑해야하는데
이때 한땀한땀 맵핑해서 DB에 저장 및 조회 ( CRUD ) 해야 합니다.
그런데 이게 단순 작업의 반복이라 개발자의 인력 낭비가 심함요.
그래서 이런 단순 작업을 줄이고 비즈니스 로직에 집중하자!
라는 생각으로 만든게 ORM입니다.

그리고 Java 진영의 ORM이 바로 JPA임
착각하면 안되는게 JPA는 기능을 구현한게 아니라 그냥 어떤 기능 있음~하고 써놓기만 한
인터페이스입니다.
그리고 JPA의 구현체로 Hibernate를 많이 사용함
Hibernate는 반복적인 작업 (CRUD)을 알아서 해주기 때문에 편함
하지만 어떤 방식으로 쿼리가 만들어지고 있는지는 명확히 이해하고 있어야 합니다.
편한만큼 세밀하게 조작하는건 안되기 때문에 JPQL이라고 하는 보완 문법이 필요합니다.

JPA를 spring에서는 한 번 더 추상화해서
Spring Data JPA라는 걸 제공해주는데 더 편하게 사용할 수 있습니다.
그리고 실무에서는 JPA를 QueryDSL과 조합해 사용합니다. ( 타입체크, 동적쿼리 실무에서 필수로 사용 )
근데 이건 테스트 코드의 범위를 벗어나서 따로 공부해보도록 합시다.

JPA에서는 테이블 자체도 두 객체간의 연관 관계로 접근합니다.
그래서 패러다임이 일치하게 되면서 편리해지는거임

사용하는 어노테이션은
@Entity, @Id, @Column, @ManyToOne, @OneToMany
@OneToOne, @ManyToMany ( 일대다 - 다대일 관계로 풀어서 사용하는게 가장 좋다고 말함 )
이 있습니다.

이제 코드 수준에서 직접 JPA와 테스트 코드에 대해 알아봅시다.
이전에 만들어놓았던 키오스크 기능을 다시 만들어볼거임.
살펴보면 주문과 상품 관계는 다대다 관계입니다.
이를 일대다 다대일 관계로 풀어서 다시 만들어봅시다.
방법은 중간에 맵핑 테이블을 만드는 것임

----------------------------------------------------------------------------------

Persistence Layer 테스트 1

요구사항
(1) 키오스크 화면에 상품 리스트 보이게 해주셈 -> 비즈니스 로직 ( DB에서 데이터 꺼낼때 DTO에 담아서 보내기 )
(2) 상품의 상태 : 판매중, 판매보류, 판매중지 변경 가능하게 해주셈 -> enum으로 구현
(3) 상품 데이터 속성은 id, 상품번호, 상품타입, 판매상태, 상품이름, 가격 총 5가지로 해주셈 -> 상품 객체 생성 및 JPA 사용

enum을 사용해봅시다.
enum 클래스에서 만들어지는 enum 상수들은 public static final로 만들어짐.
쉽게 말해서 한 번 만들어놓으면 다른 곳에서는 변경이 불가능한겁니다.

근데 이걸 왜 쓰는지 알아야겠죠
아무 생각없이 그냥 따라만치고있으면 따라치기 장인이 될 뿐임.
enum상수는 협업할때 실수로 수정될 일이 없음
그리고 사람들이 변경할 필요가 없는 값이라고 인식하기 때문에 개발 고민 시간도 줄여줍니다.
그리고 enum 상수는 enum 클래스에서 생성했기 때문에 변경사항이 생겼을때 enum 클래스로 가야 고칠 수 있는데
다시 말하면 enum 부분에 문제가 생겼을때도 유지보수하기 쉽습니다. 어디서 문제가 발생했는지 명확하지 않습니까

@RequiredArgsConstructor에 대해서도 알아보면
final 또는 @NonNull로 선언된 모든 필드를 매개변수로 받는 생성자를 자동으로 생성해주는건데
enum 클래스에서 enum 상수랑 같이 쓰면 편함.

@MappedSuperclass에 대해서 알아봅시다.
이걸 왜 쓰는지부터 알아야하는데
간단히 말하면 부모 엔터티의 속성을 자식 엔터티에서도 쓸 수 있게 엔터티에 상속 기능을 부여하는 겁니다.
그래서 BaseEntity 같은 이름의 부모 엔터티를 만들어놓고 여기에 공통 속성을 적은 다음
필요한 엔터티(자식 엔터티)에게 상속받게 하는거임
참고로 여기서는 생성 시간과 변경 시간을 공통 속성으로 넣도록 합시다.

enum 클래스와 List.of() 메서드의 활용
(1) 불변 리스트 생성: List.of() 메서드는 생성된 리스트를 불변으로 만듭니다. 즉, 리스트가 생성된 이후에는 요소를 추가하거나 제거하는 등의 변경 작업을 할 수 없습니다.
(2) 간편한 리스트 생성: 여러 개의 요소를 전달하여 간편하게 리스트를 생성할 수 있습니다. 코드의 가독성을 높이고, 리스트를 직접 생성할 때보다 간편한 방법을 제공합니다.
(3) Null 요소 불허: List.of()로 생성된 리스트는 null 요소를 허용하지 않습니다. 만약 null 요소가 포함된 경우, NullPointerException이 발생합니다.

다음은 JavaDoc 기능을 이용해봅시다.
레파지토리에 query method를 만들건데 위쪽에 JavaDoc 기능을 이용해 주석을 달아주는 게 좋습니다.
SQL문으로 주석을 달아주면 되는데 조건이 많아지면 결과를 예측하기 힘들어서 그렇구요.
단축키는 /** 입력 후 엔터를 누르면 됩니다.
JavaDoc 주석을 쓰면 좋은 점은 코드를 문서로 자동 생성해준다는 것인데
HTML 형식의 문서를 생성 할 수 있음. API 문서, 라이브러리 문서 같은 걸 만들 수 있겠죠

@Build
객체를 생성할때 builder()와 build() 메서드를 사용해야 객체 만들기 가능해집니다.
이거 왜 사용하냐구요
생성자나 세터를 사용하는 것보다 직관적이고 가독성이 좋아서 사용합니다.

application.yml을 사용해봅시다.
이걸 왜 사용하는지 또 알아야겠죠
application.properties랑 비교해봅시다.
YAML은 같은 내용을 더 적은 코드로 표현할 수 있습니다. 설정 파일을 직관적이고 가독성있게 정리할 수 있다는 것임
그래서 프로젝트가 복잡해질 수 록 YAML로 설정파일을 작성하면 좋습니다.

설정을 보면
spring profile부터 보이는데
이게 뭐냐면
테스트 환경에서는 A로 설정
로컬 환경에서는 B로 설정
이런식으로 환경을 분리하는건데
쉽게 말하면 환경마다 설정을 다르게 할 수 있는것이구요

jpa 설정을 보면 ddl-auto라는 것도 보입니다.
이게 뭐냐면 서버를 실행할때마다 매번 ddl로 데이터베이스 구조 새로 만들건지 설정하는것임
여기서 구조는 테이블 말하는겁니다.

그리고 ddl이 뭐냐면 Data Definition Language인데 데이터베이스 구조 만들때쓰는 언어임
아무튼 ddl-auto를 create로 설정하면 실행시킬때마다 테이블을 삭제하고 다시 생성함
근데 이런식으로 매번 만들고 삭제하고 반복하는건 개발 환경에서 하는게 좋지
실제 서비스에서 이렇게 해버리면 중요 데이터 다 날아가구요.

defer-datasource-initialization라는 속성도 보이는데
이게 뭐냐면 가게 영업 준비 시간도 안됐는데 식당 앞에 있으면 음식 먹을 수 있습니까 안되죠
이것처럼 Hibernate 초기화 끝난 다음 data.sql을 실행시켜달라는것입니다.
초기 개발할때만 data.sql을 사용하는데 뭔가 기능 개발하고 나서 결과를 눈으로 보려고 넣는거구요.

나중에는 안씀
그래서 테스트 환경에서는 init 모드가 never입니다. data.sql 안쓰겠다는 것임

컨트롤러 : Presentation Layer ( 사용자와 상호작용 담당 )
레파지토리 : Persistence Layer ( CRUD 작업 담당 )
서비스 : Busincess Layer ( 비즈니스 로직 담당 )

여기까지 한 사이클을 돌면서 기능을 개발해봤습니다.
이제 테스트 코드 작성해볼 것임

----------------------------------------------------------------------------------

Persistence Layer 테스트 2

JavaDoc으로 레파지토리에 쿼리 메서드를 만든 다음 주석을 꼭 달아줍시다.
그리고 테스트 코드 작성은 꼭 해주는게 좋은데
그 이유는
(1) 조건이 많아지면 내가 생각한 결과와 다른 결과가 나올 수 있음
(2) JPQL이나 Querydsl, Mybatis 등을 이용해서 다시 만들 수 있기 때문입니다.

레파지토리는 통합테스트라고 해도 단위 테스트의 성격에 가까운데
DB에서 데이터 입출력하는 것만 테스트하기 때문에 복잡하지 않기 때문에 그렇구요

테스트 작성 방식은 2가지 정도가 있습니다.

(1) @SpringBootTest
스프링 서버를 띄워서 테스트하게 해줌

(2) @DataJpaTest
스프링 서버를 띄우긴 하는데 JPA 관련 빈들만 테스트하는 목적이라 가벼움

테스트 시작하기 전에 spring properties를 설정해줍시다.
@ActiveProfiles("test")
spring profiles를 test로 설정

이렇게 설정하고 시작합시다.

원하는 상태의 제품을 조회하는 기능을 만들거니까
DisplayName에 이름 위 내용 그대로 써주면 되구요.

데이터 생성한 다음 DB에 넣어야하니까
Product에 생성자 만들어줍시다. 여기서 @Build 붙여서 필더 패턴으로 객체를 생성해줍시다.

given 부분 채워줍시다.

when 조회 기능 넣기

then 테스트 순서는 크기 -> 테스트할 항목 설정 -> 일치하는지 확인 하시면 됩니다.

----------------------------------------------------------------------------------

Business Layer 테스트 1

롤백에 대한 트랜잭션을 보장한다?

비즈니스 레이어는 Persistence 레이어와 상호작용을 하기 때문에
통합 테스트도 2개의 레이어를 함께 하는 느낌으로 진행됩니다

요구사항

상황 설명부터 해봅시다.
식당에 가보면 키오스크로 주문할 수 있는 식당들 있지 않습니까
결제는 마지막에 하고 주문만 접수해주는 키오스크 말하는거구요
여기서 메뉴를 2개정도 선택한 다음 주문하기를 누르면 총 금액도 바로바로 계산해주지 않습니까
이런 상황인거구요.
주문하기를 누르면 주문 접수 상태로 바뀌고 주문 시간도 기록이 돼야합니다.
그래야 나중에 시간별 주문 금액 확인 같은거 할 수 있습니다.

글로 정리해보면
(1) 상품 리스트 받아서 주문 생성하기 <- 다대다 관계
(2) 각 주문은 주문 상태와 주문 등록 시간이 있음 <- Order 속성에 추가
(3) 각 주문에는 상품의 총 금액이 계산돼서 들어있음 <- Service에 작성

근데 다대다 관계가 뭔지 정확히 보고 넘어갈 필요가 있을 것 같습니다.
상품과 주문으로 살펴봅시다.
아메리카노는 주문1, 주문2, 주문3 이런 식으로 여러 주문에 들어갈 수 있지 않습니까.
반대로 주문1에는 아메리카노만 들어있는게 아니라 라떼, 케이크 등 여러 상품도 들어갈 수 있습니다.
이런식으로 서로가 1개씩만 담을 수 있는게 아니라 여러개를 담을 수 있으면 다대다 관계라고 함

아무튼 그럼 단계를 나눠서 구현해보도록 합시다.
다대다 관계는 일대다 다대일로 나눠서 만들면 좋다고 했죠.
이렇게 하는 방법은 중간에 중계 테이블을 만드는 겁니다. OrderProduct라고 만들면 되겠는데요.
그리고 앞에서 배웠던 TDD 방식으로 만들어봅시다.

[1단계] 일단 상품을 담아서 주문을 생성할 수 있게 만들어봅시다.
1. 상품 3개 준비 ( 근데 build 패턴으로 만들려니까 너무 길어서 메서드를 하나 만들어줍시다. Ctrl + Alt + M 누르면 단축키임 )
2. 리스트로 만들기
3. 리스트 받아서 주문 생성하기
4. 주문이 상품과 일치하는지 확인하기

근데 Order라는 도메인을 만든 적이 없는데요
당연히 먼저 만들어줘야겠죠
주문 상태랑 주문 등록 시간도 넣으라고 했으니까 넣고 총 금액도 계산하라고 했으니까
총 3개의 속성이 있으면 될 듯.
주문 상태, 주문 등록 시간, 총 가격
이 중에서 주문상태는 enum 클래스로 만들어주도록 합시다.
만들고나서 중계 테이블인 OrderProduct랑 연계도 하면 됨. ( OrderProduct에 @ManyToOne 넣어주면 됨 )

얼추 준비는 끝난 것 같으니까
이제 1단계부터 만들어봅시다.

그리고 주문 생성 시 확인해야할 것이 있죠
(1) 상품 금액 총합 계산해줌?
(2) 주문 상태 있음?
(3) 주문 등록 시간 기록됨?

그럼 각각 만들어봅시다.
상품 금액 총합부터 만들어보면

(1) 상품 3개로 리스트 만들어서 준비
(2) 주문 생성하기
(3) 생성된 주문의 가격 총합이 예상 가격과 일치하는지 확인

주문 상태 존재 확인
(1) 상품 3개로 리스트 만들어서 준비
(2) 주문 생성하기
(3) 생성된 주문의 주문 상태가 예상과 일치하는지 확인

주문 등록 시간 기록됨?
(1) 상품 3개로 리스트 만들어서 준비
(2) 주문 생성하기
(3) 생성된 주문의 주문 등록 시간이 예상과 일치하는지 확인

(1) Order
(2) OrderRepository
(3) OrderController
(4) OrderService
(5) OrderProduct ( 중계 테이블 )
(6) OrderCreateRequest ( DTO )
(7) OrderResponse ( DTO )

----------------------------------------------------------------------------------

Business Layer 테스트 2

(1)
생각해볼 수 있는 예외케이스가 있습니다.
중복되는 상품번호 리스트로 주문 생성 요청이 들어오면 어떻게 할겁니까
상품번호 1번을 2번 담으면 당연히 상품 1번 2개로 처리해줘야겠죠
잘되는지 테스트해봅시다.

근데 안되는데요
그 이유는
OrderService를 살펴보면 findAllByProductNumberIn()으로 데이터를 찾아오고 있죠
In절로 데이터를 찾아오면 중복이 제거된 데이터를 찾아옵니다.
그래서 중복 제거 안되게 추가 처리를 해줘야함

stream을 사용하면 좋을듯
왜냐하면 컬렉션의 로직처리를 도와주는게 stream이니까요
참고로 List, Map, Array 같은 것들이 컬렉션이구요
아무튼 List도 Collection이라고 했죠. stream을 사용해봅시다.

stream에는 collect() 메서드가 있습니다.
말그대로 stream 요소를 List, Map, Set 등으로 변환하기 위해 collect 뜻 그대로 모아주는 것임
collect(Collectors.toList())라면 모아준 stream 요소를 List로 바꾸는 것입니다.

(2)
근데 테스트 코드 2개 중에 하나만 성공하는데요
왜 이럼?
그건 먼저 실행한 테스트 코드에서 데이터를 사용해놓고 뒷정리를 안해서 그렇습니다.

사실은 테스트가 끝날때마다 레포지토리 생성한 것을 다 제거해줘야함
그렇지 않으면 다른 테스트에 영향을 주기 때문이구요.
그럼 어떻게 해야하냐?

@AfterEach
void tearDown() {
    Repository.deleteAllInBatch();
}

테스트 코드가 끝날때마다 레포지토리를 삭제해주면 됨.

근데 예전에 전에 했던 레포지토리 단위 테스트에서는
3개를 한방에 테스트 돌려봐도 문제 없었는데
갑자기 왜 이럼?
이렇게 질문할 수 있습니다.

결론부터 말하자면
DataJpaTest랑 SpringBootTest의 차이점 때문이구요
DataJpaTest는 자동으로 테스트 하고나서 롤백이 되는데
SpringBootTest는 그런게 없음
그래서 테스트 끝나고나서 다 제거해줘야합니다.

(3)
일단 주문 생성 요청이 들어오면
OrderController를 통하겠죠

여기에는 PostMapping 메서드가 있습니다.
상품 번호 리스트를 받아서 주문을 생성하기 위해 요청처리하는 기능임
만들어준 OrderResponse 객체를 return 시킨 후 제대로 작동하는지 테스트 해봅시다.

PostMapping 처리가 잘되는지 확인해야하려면 HTML 파일 만들어서 요청 보내야하는데
다 만들면 좀 귀찮으니까 간단한 방법을 하나 소개하겠습니다.
HTTP 파일을 이용하는 방법임
H2를 이용하는 방법도 있습니다.

디렉토리 제일 최상단에 http 디렉토리를 만드시구요.
order.http라는 파일 만들고 여기에 요청 보낼 URL 입력하면 됩니다.

----------------------------------------------------------------------------------

Business Layer 테스트 3

요구사항
(1) 주문 생성 시 재고 확인 및 개수 차감 후 생성하기
(2) 재고는 상품번호를 가진다
(3) 재고와 관련 있는 상품 타입은 병 음료, 베이커리다


생각 정리
- 재고 도메인 만들기 ( id, 개수, 상품번호 )
    병 음료, 베이커리 타입에만 재고가 추가됐는지 확인

- 병 음료, 베이커리 타입에 포함되면 true를 반환하는지 테스트 ( ProductType에서 속성 추가 )
    미래를 대비하는 것 ( 코드를 짜다가 실수로 재고 속성이 있는 상품을 다른 타입으로 바꿔버릴 수 있으니까 )

- 재고 속성있는 상품리스트로 주문 생성 되는지 테스트
    재고 관련 주문 시 재고 감소되는지 확인
    해피케이스 : 주문 개수 < 재고
    예외 케이스 : 주문 개수 > 재고


---

[1] 재고 도메인 만들기
속성 : id, productNumber, quantity
여기서 productNumber는 product랑 @oneToMany 같은 연관 관계를 맺을 수 있습니다
근데 사실 연관 관계는 안맺는게 편하구요. 왜냐면 관계를 맺으면 처리할 작업이 많아져서 그렇습니다.
그니까 생략할 수 있음 생략하십쇼.

만들었으니까 테스트 진행해야겠죠

---

[2] 재고 관련 타입 추가하기
병 음료랑 베이커리만 재고 있는거 아닙니까
그럼 이 둘만 재고 관련 타입으로 만들어주면 될 듯

ProductType enum 클래스에
재고 관련 타입 List로 병 음료랑 베이커리 넣어주면 될 것 같습니다.

상품 타입이 재고 관련 타입인지 체크하는 테스트 진행
1. 상품 타입이 재고 관련 o일때 true가 나오는지
2. 상품 타입이 재고 관련 x일때 false가 나오는지

---

상품번호 리스트로 재고를 조회하는 테스트
해피 케이스 : 재고 > 주문 수량
예외 케이스 : 재고 < 주문 수량 ( 경곗값 테스트 )

재고의 수량이 제공된 수량보다 작은지 확인한다.
재고를 주어진 개수만큼 차감할 수 있다.

---

테스트에 @Transactional을 보통 붙여서 사용합니다.
근데 이거 왜 사용할까요
이걸 사용하면 데이터베이스의 입출력 단위인 트랜잭션을 알아서 관리해줘서 편리합니다.
구체적으로 삭제 후 레포지토리를 다 지운다든지하는 것을 신경쓰지 않아도 됨

트랜잭션이 뭐냐면
DB의 작업들은 보통 삽입, 삭제, 수정 같은것들을 한 번에 묶어서 동작하는데
이런 것들의 묶음을 트랜잭션이라고 부릅니다.
예를 들면, 삽입 - 삭제 - 수정이 하나의 트랜잭션이 될 수 있다는 것

아무튼 이런 트랜잭션 하나하나가 DB 작업의 단위가 됩니다.

이 트랜잭션이 어떻게 동작하는지도 상세히 보자면
트랜잭션 안의 작업들이 모두 성공해야 DB에 반영되고 하나라도 실패하면 롤백됩니다.
그래서 일관성과 무결성을 지켜준다고도 말함

그럼 다시 @Transactional을 봅시다.
이 트랜잭셔널 어노테이션은 트랜잭션 관리를 자동으로 해주는 것이라고 했습니다.
근데 이 트랜잭션의 경계는 어떻게 나누는 거죠.

예를 들면, 삽입 - 삭제 - 수정이 하나의 트랜잭션인데
삽입 - 삭제 까지만을 하나의 트랜잭션으로 볼 수 있지 않겠습니까

트랜잭셔널 어노테이션을 쓰면 이런 경계를 자동으로 나눠주기 때문에
테스트 코드에선 정상적으로 동작했는데
실제 코드에서는 정상 동작하지 않는 문제가 발생할 수 있구요
그래서 이런 경계가 달라질 수 있다는 것을 확실히 알고 넘어가야함.

그리고
사실 재고감소 문제도 간단한게 아닙니다.
키오스크가 1대가 아니라 2대면 어떻게 할거임
동시에 요청을 했으면 누가 먼저 재고를 감소시킬거죠
이런건 동시성 문제라서 나중에 찾아서 공부해보도록 합시다.

----------------------------------------------------------------------------------

Presentation Layer 테스트 1

외부 세계의 요청을 가장 먼저 받는 계층
파라미터에 대한 최소한의 검증을 수행한다

비즈니스 로직을 수행하기 적절한 값인지 검증하는게 핵심이다.

Mocking
테스트 중인 코드에 실제 객체나 함수 대신 가짜 객체나 함수를 만들어서 사용하는 것
왜 이렇게 하냐면
실제 객체나 함수를 사용할 경우 외부의 영향을 받을 수 있기 때문입니다.
예를 들어,
기능 A를 테스트하려는데 괜히 B, C, D 같은 것들이 영향을 미쳐서 A를 테스트조차 못하게 될 수 있다는 것입니다.

Controller 테스트를 진행할때는
Repository와 Service를 가짜로 만들어서 잘 동작한다고 가정하고 ( Mocking ) 단위테스트를 진행할 예정임.

MockMvc
Mock (가짜) 객체를 사용해
스프링 MVC 동작을 재현할 수 있는 테스트 프레임워크

요구사항
관리자 페이지에서 신규 상품을 등록할 수 있다
상품명, 상품 타입, 판매 상태, 가격 등을 입력받는다.

Controller에서 요청을 받아서
상품 생성하고 저장해야하니까
PostMapping 함수를 하나 만들어줍니다.

이 맵핑함수에 필요한 건
1) 요청
2) 상품 생성
3) 상품 저장
4) 신규 상품이면 상품번호 증가

이렇게 4가지가 필요할듯요.

1) 요청은 requestDTO를 통해 받고 만들어줍시다. ( productNumber는 따로 뺌 )
2) 상품 생성은 ProductService에서 메서드 하나 만들어주면 될 듯 createProduct()라는 이름이면 적당하겠는데요
3) 상품 저장은 ProductRepository에서 저장하면 되겠죠.
4) 상품 번호 증가는 ProductService에서 로직 만들면 될 듯요

이제 순서대로 만들어봅시다.

상품 번호를 증가시키려면 마지막 상품의 상품 번호를 알아야겠죠
그래야 거기에 1만큼 추가해서 다음 번호를 만들 것 아님

해피케이스 : 상품 마지막 번호에서 +1을 한 다음 신규 상품을 만들 수 있다.
예외케이스 : 상품이 하나도 없는 경우는 "001"이 새로운 상품 번호다.

그런데 이런 상품등록을 여러명이 할 수 있다고 하면 어떡할거예요
동시성 문제가 발생할 수 있지 않습니까
이런 문제를 방지하기 위해서 UUID같은 걸 사용할 수 있는데
이게 뭐냐면
상품 번호에 유니크한 값을 줘서 애초에 상품번호가 겹칠 일이 없게 하는겁니다.
이러면 동시에 상품 만들거나해도 동시성 문제가 없을듯요

---

@Transactional(readOnly = true)에 대해 알아봅시다.
readOnly는 번역하면 말그대로 읽기 전용이죠.
읽기 전용같은 속성을 어디에 쓸지 생각해봅시다.
트랜잭션은 DB의 작업 묶음 단위라고 했습니다.
그럼 DB랑 관련있을 것 같은데요.

DB에서 하는 작업을 CRUD ( Create Read Update Delete )라고 하죠
readOnly를 하게되면 CRUD중에 CUD가 동작을 안하게 되는 것임.
다시 말해서 CUD랑 R이 분리가 되는겁니다.
근데 이런거 분리해서 뭐하냐구요

이걸 깊게 이해하기 위해선 DB에 대한 이해가 필요함
우선 DB 종류부터 살펴봅시다.
DB에는 2종류가 있습니다.
마스터 DB랑 슬레이브 DB인데
이게 뭐냐면
마스터 DB는 능동적인 친구라 하고싶은걸 다 할 수 있는 친구임
구조를 바꾸는 행위들은 다 여기서 일어납니다. Update, Insert, Delete 같은 것들은 구조를 바꿀 수 있죠

그리고 슬레이브 DB는 끌려다니는 수동적인 친구라고 생각하면 되는데
쉽게 말해 구조에 영향을 주지 못하는 Read밖에 못함요

그래서 마스터DB와 슬레이브DB 관점으로 보면
CRUD를 Command와 Read로 크게 나눌 수 있습니다.
근데 둘의 작업 비율은 2:8정도로 Read가 훨씬 많음

그럼 마스터 DB랑 슬레이브 DB를 나눠서
마스터 DB에게는 CUD만 시키고 슬레이브DB에만 Read 시키면 성능 빨라질듯요
실제로 이렇게 하면
JPA에서도 스냅샷 저장, 변경 감지를 안하게 돼서 성능이 빨라짐 ( JPA에 대해서 더 공부해봅시다 )

아무튼
조회용은 @Transactional(readOnly = true) : 슬레이브 DB
커맨드용은 @Transactional : 마스터 DB
이렇게 나눠서 트랜잭셔널 어노테이션 붙이면 성능향상에 좋습니다.

그래서 CQRS라는 설계 패턴도 있는데
이게 뭐냐면
CQRS ( Command Query Responsibility Segregation ) : Command와 Read를 분리하자임.

이것의 첫 번째 단계가 읽기전용을 구분하는 것이구요.

아무튼 이를 적용해봅시다.
방법은
Service 클래스에는 @Transactional(readOnly = true)를 걸고
커맨드 작업일 경우에만 메서드에 @Transactional을 거는 것임

----------------------------------------------------------------------------------

Presentation Layer 테스트 2

이제 Controller 테스트를 진행해봅시다.
총 2가지를 알아야하는데

1. WebMvcTest 어노테이션
2. Mockito 프레임워크 사용법

이 둘입니다. 참고로 이 둘은 세트 상품임.

먼저 WebMvcTest 어노테이션부터 봅시다.
이게 뭐냐면 Controller 테스트 전용 어노테이션이라고 생각하시면 됨
정확히는 컨트롤러만 테스트할 수 있게 컨트롤러 관련 빈으로 서버를 띄워주는 것입니다.

그리고 추가로 알아둬야할게 있는데 Controller는 Service 빈이 있어야 정상적으로 기능을 수행할 수 있습니다.
근데 만약 없으면 어떡하냐구요.
그럼 front-end에서 보낸 요청을 DB에 저장하거나 조회하는 등의
비즈니스 로직을 Controller에서 만들어줘야하는데
이러면 Service와 Controller가 합쳐져 있는거 아닌가요

이럼 나중에 유지보수하기 불편해집니다.
그래서 분리하는게 좋습니다.

아무튼 Controller에는 Service가 빈으로 등록돼있어야한다는 걸 알았습니다.
근데 생각해볼게 있음.
테스트할때는 영향을 받거나 주는게 없는게 좋다고 하지 않았습니까
근데 Controller는 Service에 엄청 의존하고 있는데요.

그럼 가짜로 Service 빈을 만들어놓고 Controller만 진짜를 사용해서 테스트하면 좋을듯
이런 방법을 위해 Mockito 프레임워크를 사용하는것임

그럼 가짜 Service 빈을 만들어봅시다.
방법은 간단한데 @MockBean을
Service 위에 붙여서 Mock Bean으로 등록하면 끝임

---



verify
상황을 설정하고 반환받을 값을 설정할 수 있음


ObjectMapper에 대해 알아봅시다.
이게 뭐냐면 Object를 JSON 형태로 맵핑해주는 도구임
HTTP 통신을 할때는 Object를 JSON 형태로 바꿔야한다고 했었죠
이걸 개발자들 용어로 직렬화라고 합니다.
그럼 반대로 JSON형태를 Object로 바꾸는 건 뭐게요.
역직렬화입니다.
아무튼 ObjectMapper는 이를 쉽게 해주는 애임
이거 어디에 쓰냐구요. MockMvc로 Controller 테스트할때 씁니다.

역직렬화는 어떨때 쓰는지도 자세히 살펴봅시다.
POST요청이 들어오면 데이터가 어떤 형태로 들어오게요.
HTTP 통신할때 JSON형태로 들어온다고 했었죠
그럼 이거 서버에서 다시 Object로 바꿔야 뭐든 할 수 있지 않겠습니까
여기서 필요한게 역직렬화 작업이구요.

참고로 역직렬화 할때 requestDTO를 사용한다면 기본 생성자가 필요함
그래서 @NoArgsConstrutor를 붙인 requestDTO를 만들어주면 좋습니다.

@EnableJpaAuditing은
JPA 엔티티에서 생성 및 수정과 관련된 메타 데이터를 자동으로 관리하기 위해 Spring Data JPA에서 제공하는 애노테이션입니다.
이 기능을 사용하면, 엔티티가 생성되거나 수정될 때 자동으로 날짜, 시간, 사용자 등의 정보가 기록됨

Controller에서 요청으로 들어온 변수들을 검증해주는 게 필요하다고 했습니다.
이를 쉽게 도와주는 친구가 바로 validation 라이브러리임
build.gradle에 추가하시면 됩니다.
그리고 사용법도 알아보자면 2가지를 기억하면 됩니다.
1) 검증하고 싶은 변수위에 어노테이션을 붙이기
@NotNull
@NotBlank
@Positive
이런거 붙이면 되구요.
2) 매개변수 자리에 @Valid 붙이기
구체적으로 @Valid @RequestBody ProductCreateRequestDTO request
이런식으로 하시면 됨

그리고 하나 더 생각해볼게 있습니다.
서버에서 프론트에게 응답을 줄때 JSON 형태로 주면 된다고 했죠.
근데 이때 응답의 형태를 통일해주면 좋습니다.
ResponseEntity<>를 사용할 수 있지만 직접 만드는 방법도 있음.
직접 만들어봅시다.
ApiResponse라는 형식을 만들면 좋을듯

메타 정보?

ApiResponse라는 클래스파일을 만들어주면 됨
HttpStatus
message
성공에 대한 data를 응답해줌

jsonPath?

Validate

ControllerDTO와 ServiceDTO를 분리하는게 좋음

layered 아키텍처
hexagonal 아키텍처

squash and merge
테스트용임

테스트