----------------------------------------------------------------------------------

한 문단에 한 주제

하나의 테스트에는 하나의 주제만 검증하라는 것입니다.

테스트 코드를 짜다보면 if문이나 반복문같은 것들이 필요할때가 있는데
이럴 경우에 테스트 코드를 그대로 써내려가지말고
케이스를 나눠주면 됩니다.

왜냐면 분기문과 반복문 같은 논리구조가 들어가있다는 것 자체가
2가지 이상의 케이스를 구분하겠다는 것이기 때문임.

그리고
반복문이나 분기문이 테스트 코드에 들어있으면
테스트 코드를 읽는 사람이 논리 구조를 한 번 생각해봐야하기 때문에
무엇을 테스트하는지 명확히 알기 어렵습니다.

앞으로 테스트 코드를 만들때 이런것들을 잘 기억해서 협업 장인이 되도록합시다.

Parameterize 개념 참고하셈

----------------------------------------------------------------------------------

완벽하게 제어하기

쉽게 말해서 제어할 수 없는 것을 분리하라는 것입니다.
이미 앞에서도 말했지만 제어가 안되는 것들은
파라미터로 분리하는게 좋습니다.
( 가능하다면 Mocking 처리를 하는 것도 좋음. )

예를 들어
현재 시간을 테스트 코드에 넣는다고 해봅시다
근데 현재 시간은 계속 변하는 값인데요.
이거 어떻게 제어하죠.
결론부터 말하자면 제어 안되구요. 이런걸 따로 분리하자는 것입니다.
제어할 수 있도록 시간을 파라미터로 주입받도록 하면 좋을듯요.
이렇게 하면 파라미터로
고정된 시간을 넣어서 테스트 코드를 작성할 수 있을듯.
그리고 프로덕션 코드에서는 현재시간 넣으면 정상 작동하겠죠.

----------------------------------------------------------------------------------

테스트 환경의 독립성을 보장하자

OrderServiceTest를 보면
given절에서 deductQuantity(3)처럼 구성하면 given 절 때문에 에러가 터짐
제대로 분리가 안됐다는 것임
그리고
객체를 생성할때도
팩토리 메서드를 쓰지않고 순수하게 빌더 패턴으로 만드는게 좋음

팩토리 메서드로 객체를 만드는 것은 필수 값을 검증한다든지 하는 목적이 있을때임.
그래서 프로덕션 코드에서 특정 목적을 갖고 팩토리 메서드를 만들어놨는데 이를 테스트 코드에 사용하면
이상한 로직같은게 끼어들어갈 수 있다는 것임

그렇기 때문에 테스트 코드에서는 빌더 패턴을 이용해서 객체를 생성해주는 것이
특정 목적없이 순수하게 객체만 생성하려는 목적에 맞다는 것임

----------------------------------------------------------------------------------

테스트 간 독립성을 보장하자

공유 자원을 사용할 경우 테스트의 순서에 따라 랜덤 가챠처럼 성공과 실패가 달라질 수 있습니다.

예를 들어,
A : 1을 더해서 2가 된다.
B : 1을 빼서 0이 된다.
이런 테스트가 있다고 해봅시다.
여기서 공유자원으로 a는 1이라고 선언해놨음.

여기서 A먼저 실행하면 A는 성공 나오겠죠
근데 B는 어떡할거예요. 2 - 1 = 1이니까 실패인데요

그럼 이번엔 B먼저 실행시켜봅시다.
당연히 B는 성공인데. A는 0 + 1 = 1이니까 실패인데요
이런식으로 공유자원을 사용하면 순서에 따라 결과가 달라질 수 있음.

그러니까 공유자원은 테스트 코드 작성할때 사용하지 맙시다.

근데 공유 자원이 변화하는 모습을 테스트하고 싶으면 어떡할거예요.
사실 방법이 있습니다. DynamicTest를 사용하면 됨.
뒤에서 구체적으로 봅시다.

----------------------------------------------------------------------------------

한 눈에 들어오는 Test Fixture 구성하기

Fixture : 고정물
given절에서 생성한 모든 객체를 Test Fixture라고 함

4가지 조언
@BeforeAll : 전체 테스트 전에 1번 실행해줌
@BeforeEach : 테스트 메서드 하나마다 실행해줌

1. @BeforeEach을 사용해서
공유 자원으로 객체 생성하면 안좋습니다.
테스트 코드를 문서로 사용하기 어려워짐 ( 위를 꼭 확인해봐야 테스트 코드가 이해되기 때문 )

1) 내용을 몰라도 테스트 코드를 읽는데 문제가 없다.
2) 수정해도 모든 테스트에 영향이 없다.
이럴 경우만 @BeforeEach 달아서 공유 자원처럼 관리 해도 괜찮음

---

2. data.sql 같은거 만들지 마라

---

3. 빌더 패턴 만들때
파라미터는 테스트에 필요한 필드만 넣을 수 있도록 하는게 좋다.

---

4. 빌더 패턴을 따로 모아놓은 파일을 만들어서 분리하면 복잡해짐 하지마셈
테스트마다 빌더 패턴을 구성하는 게 귀찮지만 이렇게 하는게 좋음
코틀린을 사용하면 어느정도 해결가능하긴 함

----------------------------------------------------------------------------------

Test Fixture 클렌징

deleteAll
deleteAllInBatch
차이점?

deleteAll은 엔터티를 먼저 조회하고 하나씩 삭제해서 엔터티가 많으면 성능 문제가 발생함
deleteAllInBatch 1번만 삭제함. 관계가 형성돼있는 엔터티들의 삭제 순서가 중요해짐

----------------------------------------------------------------------------------

@ParameterizedTest

if문 같은 분기문이 있을때

@CsvSource
, 구분자로 이루어진 형식

@MethodSource
Stream 형식 데이터

Spock 테스트 프레임워크는 @ParameterizedTest가 명시적이다.

----------------------------------------------------------------------------------

@DynamicTest

하나의 주제인데 공유 자원을 사용할 경우
시나리오를 테스트할때 좋다?
@TestFactory를 만들어두고
안쪽에 @DynamicTest를 여러개 넣어서 구성함

----------------------------------------------------------------------------------

테스트 수행도 비용이다. 환경 통합하기

사람이 직접 테스트 하지 않아서
수시로 테스트할 수 있음.
비용을 줄이는 것이 테스트 코드의 목적임

전체 테스트를 하는 경우
1) 기능 하나를 만들고 commit 할때
2) Feature 브랜치의 기능을 다 만들어서 develop 브랜치에 push 할때

동일한 환경으로 맞춰줘야 테스트를 수행할때 서버를 여러번 실행시키는 일이 적어져서 시간을 아낄 수 있다.

Mock Bean 처리된 객체가 있으면 서버를 동일한 환경으로 맞춰도 2번 띄워야함.
2가지 처리 방법이 있음
1) 상위 클래스로 올려서 수행하는 방법
2) 테스트 환경을 2개로 나누기
- Mock bean
- Mock bean 없는 환경

결론
1) Repository + Service를 하나의 통합된 환경
2) Controller를 하나의 통합된 환경

2개의 통합 환경을 띄우자

전체 ApplicationTest는 지우고 시작
오른쪽 Gradle에서 test를 눌러 전체 테스트하기

----------------------------------------------------------------------------------

Q. private 메서드는 테스트 안함?

결론부터 말하자면 할 필요가 없습니다.
해서도 안됨

왜냐하면 내부 로직을 굳이 공개할 필요가 없기 때문입니다.

정리하자면
공개 API의 기능이 너무 많아서
공개 API를 2개로 나눠야겠다.
뭐 이런 상황이면 테스트 코드를 나눠서 작성하시구요.
아니면 신경 안써도 됨.

----------------------------------------------------------------------------------

Q. 테스트에서만 필요한 메서드가 생겼는데 어떻게 함?

Getter, 기본 생성자, 생성자 빌더, 사이즈 이런것들이 있는데
결론은 위에서 언급한 생성자처럼 계속 사용될 만한 메서드라면 만드셔도 됩니다.









