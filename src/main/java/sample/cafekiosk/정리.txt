
일을 잘하는 개발자들이 하나같이 말하는 것 중 하나는
테스트가 중요하다입니다.

왜 중요할까요?
왜 중요한지 모르고 그냥 따라서 만들기만 하면 AI가 바로 대체하구요.
결론부터 말씀드리면
프로젝트의 신뢰도와 관계가 있기 때문입니다.

신뢰도가 왜 중요하냐구요.
인터넷 쇼핑몰에서 옷 주문하거나 배달어플로 음식시켜먹을때
리뷰같은거 확인하지 않습니까

왜 확인합니까
옷 품질이 구려서 못입는건 아닌지 혹은
음식점이 믿을만한지 맛있다는 평가는 받는지 등의 신뢰도를 확인하기 위해서 아닙니까

이렇듯 신뢰도는 곧 돈과 직결되기때문에 테스트는 중요하구요.

무엇보다 테스트 코드를 만들어놓지 않으면
매번 기능 만들고나서 팀원들이랑 버그가 있는지 없는지 함께 고민해봐야함

빨리 만들기만 하면 달리는 기차에 나무로 만든 바퀴 달아놓는 거랑 비슷하구요.
언제 부숴질지 모르는 불안감을 안고 가야합니다.

그럼 두번째로 테스트 코드를 잘 작성한다는건 무슨 의미일까요

프로젝트를 만들다보면 계속해서 기능 개발을 하게 될텐데
A라는 기능을 개발하고 테스트를 진행했을때는 문제가 없었지만
B라는 기능을 개발하던중에 A 코드의 일부를 수정해야할 일이 생겼다고 합시다.
이럴 경우 B도 테스트하지만 A도 다시 한 번 잘 작동하는지 테스트를 다시 진행해봐야합니다.
사람이 일일이 이걸 다 확인하고 있으면 물론 그렇게 해도 되겠지만
시간과 인력이 너무 많이 필요하지 않겠습니까

그럼 테스트 코드를 작성해서 기계가 테스트할 수 있게 만들면
효율적일 것 같은데요
이를 위해서 테스트 코드를 잘 작성하는게 중요하구요.

수동 테스트를 진행하다보면 개발 속도보다 테스트 속도가 느리기 때문에 전체적인 흐름 자체가 느려집니다.
이를 위해서도 자동화된 테스트는 꼭 필요함

테스트 코드를 제대로 짜지 않으면 생기는 문제점도 있습니다.
알아보지 못하게 코드를 작성해놓으면
팀원들이 그냥 훑어보고 테스트 코드 작성돼있으니까 잘 동작하나보다 하고 넘어가서
더 큰 문제가 발생할 수 도 있구요.

오히려 테스트 코드도 리팩토링 해봐야하는 짐덩어리가 될 수 있습니다.

잘 작성하면 테스트 코드 자체가 팀 전체가 공유하는 지식이 될 수 있고
개발 속도도 빨라지기 때문에 꼭 작성하는게 좋구요.


----------------------------------------------------------------------------------

그럼 이제 단위 테스트라는 걸 배워봅시다.

이걸 위해 간단한 예시로 카페의 키오스크 기계에 들어갈 소프트웨어를 만들어봅시다.

단위테스트가 주제니까 unit이라는 디렉토리에 만들면 좋을 것 같습니다.
여기에 CafeKiosk랑 기타 등등 필요한 걸 만들면 됨.

그리고 CafeKiosk가 잘 작동하는지 테스트하기 위해
CafeKioskTest라는 파일을 만들어서 테스트 코드를 작성해봤습니다. ( 참고로 단축키는 컨트롤 쉬프트 T 누르면 됨 )
근데 문제점이 있지 않습니까.
테스트 코드의 장점은 테스트를 자동화할 수 있는 것이라 했습니다.
근데 이건 사람이 눈으로 확인해야하는데요.
뭔가 잘못됐죠. 이건 수동테스트입니다.

문제점
1. 사람이 직접 확인해야함
2. 다른 사람이 봤을때 뭘 검증해야하는지 모르고 어떤게 맞고 틀린지도 확인이 불가능 함
3. 무조건 성공하는 케이스임

----------------------------------------------------------------------------------

테스트에는 단위테스트, 통합테스트, 인수테스트 같은게 있습니다.

단위테스트는 클래스나 메서드같은 작은 단위를 테스트하는데 이때 독립적이어야 하는데
쉽게 말하자면 외부에 영향을 받지 않고 혼자서 실행이 가능하게 만들라는 건데
예를 들면, 네트워크에 연결되어야만 한다는지 하는 식으로 외부 상황에 의존하지 않도록 하면 됩니다.

이걸 위해선 2가지 도구를 사용하면 됨.

(1) JUnit5 : 단위 테스트를 위한 테스트 프레임워크
( 참고로 XUnit의 Java 버전이 JUnit임. SUnit, JUnit, NUnit 등이 있음 )

(2) AssertJ : 테스트 코드 작성을 원할하게 돕는 테스트 라이브러리
풍부한 API, 메서드 체이닝 지원 ( 깔끔한 코드 작성 가능 )

AssertJ를 사용하면 직관적인 테스트 코드 작성이 가능합니다.
그럼 이제 직접 단위 테스트 코드를 작성해보도록 합시다.
CafeKioskTest를 이어서 작성해보도록 합시다.

----------------------------------------------------------------------------------

테스트 케이스 세분화

테스트 코드를 만들기 위해선 테스트 케이스를 나눠야합니다.
보통 고객이 요구사항을 말하면 그 기능 개발을 하고 테스트 코드를 작성해봐야하는데
일반적으로 고객들은 개발을 잘모를 경우가 많고 그냥 이거 만들어주셈 하는식으로 요구하기 때문에
개발자들은 테스트 케이스를 나누기 위해서 꼭 요구사항 검증을 해줘야합니다.

Q. 암묵적인 요구사항 혹은 아직 드러나지 않은 요구사항이 있나?
A. 해피케이스(그대로 드러나는 요구사항) / 예외케이스

그래서 이런식으로 해피케이스와 예외케이스를 나눠주면 됨
어떻게 나누냐구요

3개 이상~ 같은 조건이나 7월 25일까지 해주셈~ 같은 조건이 나오면
해피케이스 3, 예외케이스 2 처럼 케이스를 나누고
해피케이스 7월 25일, 예외케이스 7월 26일처럼 나눠주면 됩니다.

이런 방식을 경계값 테스트라고 하고
범위, 구간, 날짜같은 조건이 있을때 만족하는 경우랑 만족하지 않는 경우로 나누면 됨

그럼 바로 예시를 보도록 합시다.
요구사항 : 한 종류의 음료 여러 잔을 한 번에 담는 기능을 추가해주셈

해피케이스로는 아메리카노 2잔을 한 번에 추가하는 경우를 테스트 해보면 좋겠는데요
한 종류 음료 여러 잔 한 번에 담는 기능이니까요 맞죠.

근데 만약 음료를 0잔 아래로 주문하면 어떻게 할거예요
이런 경우도 있을 수 있겠죠. 이런 걸 예외케이스에 넣으면 되는겁니다.

먼저 CafeKiosk에 여러 잔을 주문하는 add() 메서드를 하나 작성해봅시다.
그리고 그에 대한 테스트 코드를 작성하면 됨

----------------------------------------------------------------------------------

테스트하기 어려운 영역을 분리하기

요구사항 : 가게 운영 시간 ( 10:00 ~ 22:00 ) 외에는 주문을 생성할 수 없게 해주셈

요구사항을 만족시키려면 먼저 필요한 게 주문 생성 기능이니까 키오스크에 기능을 추가해줍시다.
createOrder() 메서드에 기능을 추가하면 되구요.
그 다음 테스트 코드를 작성하면 됨.

먼저
private static final로 상수 형태의 OPEN_TIME과 CLOSE_TIME을 만들어줍시다.
그리고 이걸 기준으로 createOrder에 조건을 추가할건데
만약 테스트를 진행하는 시간이 9:00면 어떡할겁니까
이러면 10:00 전이라서 주문 생성이 안되는게 맞습니다.
근데 이러면 정상적으로 작동하는데도 테스트가 실패해버리는데요.

그럼 무조건 현재 시간을 입력받는게 아니라
원하는 시간을 입력받아 테스트 할 수 있도록 바꾸면 되는거 아닙니까
그렇게 하면 되구요.

그래서 결론부터 말씀드리면
상황에 따라 테스트 결과가 달라질 경우는 상황이 달라지는게 문제 아닙니까?
상황을 분리해버리면 됩니다.
쉽게 말하자면 방금 상황에서는 테스트를 진행하는 시간에 따라 테스트 결과가 달라지지 않았습니까
그럼 테스트 진행 시간을 입력받는걸로 분리하면 되는겁니다.

( 구체적인 방법 :
해야할 일은 먼저 매개변수로 시간을 입력받을 수 있게 createOrder()을 변경하는겁니다
createOrder(LocalDateTime currentDateTime)처럼 매개변수를 넣도록 바꾸시구요.
그 다음 원래 기능처럼 KioskRunner는 주문이 생성되면 그 주문 시점이 바로 입력되게
Order order = cafeKiosk.createOrder(LocalDateTime.now()); 코드를 작성해주면 끝입니다. )

이런식으로 테스트 결과가 상황에 따라 달라질 경우
그 상황을 테스트하기 어려운 영역이라고 합니다.
크게 2가지로 분류할 수 있는데
(1) 관측할 때마다 다른 값에 의존하는 코드 (현재 날짜/시간, 랜덤 값, 전역 변수/함수(다른 개발자 쪽에서 변경 가능하니까), 사용자 입력 등)
(2) 외부 세계에 영향을 주는 코드 (표준 출력(로그), 메세지 발송, 데이터베이스에 기록하기, 파일에 쓰기 등)
이구요.

쉽게 말하자면 매번 바뀌는 입력이나
출력이 외부에 영향을 미쳐서 변화할 수 있는 경우 ( 같은 이름의 파일이 이미 존재하고 있었다든지, 이미 존재하는 데이터가 있었다든지 등 )
에는 테스트 결과가 매번 달라질 수 있기 때문에
이런 입력이나 출력을 분리해서 테스트 코드만 똑 떼어져있는 형태가 좋은 테스트 코드입니다.

( 참고 lombok 사용법
@Data, @Setter, @AllArgsConstructor 지양
양방향 연관관계 시 @ToString 순환 참조 문제
DTO 같은 거 만들때만 @ToString 사용하기 )

----------------------------------------------------------------------------------

TDD ( Test Driven Development )

TDD에 대해 알아봅시다.
일반적인 개발 과정에서는 프로덕션 코드르 작성하고 테스트 코드를 작성합니다.
근데 TDD는 테스트 코드를 먼저 작성하는 방식임

이걸 왜 하는지가 중요하겠죠.
테스트 코드를 먼저 작성


TDE ( Test Driven Engineering )

핵심 방법 : RED - GREEN - REFACTORING
RED : 실패하는 테스트 작성
GREEN : 테스트 통과 최소한의 코딩
REFACTOR : 테스트 통과를 유지하면서 리팩토링

그럼 calculateTotalPrice() 메서드를 다시 TDD 방식으로 개발해보도록 합시다.

우선 calculateTotalPrice() 테스트 코드를 작성합니다.
키오스크에 아메리카노랑 라떼를 추가한 다음 가격을 가져와서 더하면 되겠죠
만들고나서 테스트 해보면 빨간불이 뜹니다.

당연히 CafeKiosk에 로직 작성을 해두지않았으니까 빨간불이 들어오는거구요.
최대한 빠르게 GREEN이 되게 하려면 8500이 return 되도록 하면 되죠?

이제 REFACTOR 순서입니다
8500이 나오도록 로직을 작성하면 됩니다.

추가로 이미 작성한 로직을 과감하게 수정해도 좋습니다
테스트가 기능을 보장해주기 때문입니다

일반적인 방식 (테스트 코드 마지막에 작성)으로 개발할 경우
기간 내에 개발을 마무리해야하니 아무래도 촉박해지지 않겠습니까

(1) 그래서 테스트를 아예 작성하지 못하는 경우도 있고

(2) 촉박해지다보면 시야까지 좁아지기 때문에
해피케이스에 대한 테스트 코드만 작성하고
예외케이스는 그냥 넘어갈 가능성이 높습니다.
이러면 제대로 된 테스트가 아니기 때문에 안한거랑 별반 다를게 없구요.

(3) 이미 개발을 다 해놨는데 잘못 구현한 걸 너무 늦게 발견할 수 있는데
이럴 경우 코드를 하나하나 다시 다 고치고 확인해야하기 때문에 그대로 짐싸서 나가면 됩니다.

그럼 왜 TDD 방식으로 개발하면 좋은지도 보도록 합시다.
(1) 과감한 리팩토링이 가능한 코드로 구현할 수 있음
    모든 메서드와 클래스에 테스트가 만들어져있기때문에 코드를 다시 만들기가 쉽습니다.
    GREEN만 나오게 로직을 작성하면 됨.

(2) Edge 케이스 ( 예외 케이스 )를 미리 작성해놓으니까 놓칠 확률이 낮습니다.
    이건 당연히 미리 테스트 코드를 작성 해놓으니까 여유롭게 생각할 수 있어서 그렇습니다.

(3) 피드백
    작성한 코드에 빠르게 그리고 자주 피드백을 할 수 있습니다.
    이러면 실수할 확률이 줄어들고 코드를 탄탄하게 쌓아올릴 수 있겠죠.
    그리고 무엇보다 고객들이 요구사항 바꾸는거에 스트레스 받을일이 적어짐


[키워드 정리]

애자일 방법론 vs 폭포수 방법론
    애자일 방법론에 속하는 것이 xp, 스크럼, 칸반 같은 개념입니다.
    개발 기간을 짧게 피드백을 여러번 거치면서 빠르게 진행하는것

익스트림 프로그래밍(xp)
    요구사항에 유연하게 대처하기 위한 방법임
    애자일을 위한 방법론 중 하나인데
    TDD는 또 익스트림 프로그래밍(xp)를 위한 하나의 방법입니다.
    CI/CD도 xp에 속함요

스크럼, 칸반

----------------------------------------------------------------------------------

테스트는 []다.

소프트 스킬
(1) 커뮤니케이션 능력
(2) 태도
(3) 일에 임하는 몰입도나 자세
(4) 글쓰기 능력
(5) 문서 작성 능력

테스트는 문서다.

테스트 자체가 프로덕션 기능을 설명해주는 코드 문서라고 할 수 있습니다.
다양한 테스트 케이스가 적혀있기 때문에 프로덕션 코드를 이해하는데 도움이 되구요.
무엇보다 한 사람이 테스트 코드를 잘 작성해놓으면 프로덕션 기능에 대한 이해가 깊어지기 때문에 테스트 코드 자체가 모두의 자산이 됩니다.
그렇기 때문에 테스트 코드를 잘 작성했는지를 보는것 자체가 그 사람의 소프트 스킬 수준을 나타낸다고 생각할 수 있겠습니다.

실무에서 기억해야할 것은
"우리는 항상 팀으로 일한다" 라는 것입니다.
소스 코드가 공용 자산이라면 테스트 코드는 팀 단위로 관리되는 문서라고 할 수 있습니다.
그렇기 때문에 내가 작성한 코드나 문서가 팀원에게 어떻게 비칠지를 생각하는게 좋겠습니다.

----------------------------------------------------------------------------------

DisplayName을 섬세하게

JUnit5에서 추가된 DisplayName이라는 어노테이션이 있습니다.
JUnit4를 사용했을때는 테스트 코드 메서드명을 한글로 사용하기도 했는데 이러면 띄어쓰기마다 _를 넣어야해서 불편하구요

@DisplayName("음료 1개를 추가하면 주문 목록에 담긴다.")
@Test
void add() {
    키오스크에서 주문 목록에 아메리카노 1개 추가하는 코드~~
}
처럼 테스트 코드를 처음 보는 사람도 어떤 기능을 개발하고 테스트하는 건지 명확히 알 수 있게 작성해주는 게 좋습니다.

(1) 명사의 나열보다는 문장 형태로 작성하기
(2) 행위와 그 결과까지 써주기
(3) ~테스트 같은 이름은 X
(4) 도메인 용어를 사용해서 구체적으로 표현하기 ( 카페 키오스크가 도메인이라면 특정 시간보다는 영업 시간이라고 표현하는 식 )
(5) 성공한다 실패한다보다는 현상의 결과를 적기

위 5가지는 쉽게말해
"행위와 결과를 담은 문장으로 표현하기"
라고 정리할 수 있겠습니다.

----------------------------------------------------------------------------------

BDD ( Behavior Driven Development )

TDD에서 파생된 방법입니다.
(1) 시나리오에 기반한 테스트 케이스 자체에 집중해 테스트하는 방식
(2) 개발자가 아닌 사람이 봐도 이해할 수 있을 정도로 추상화 수준을 권장

여기서 시나리오에 기반했다는건 사용자 기능이 어떻게 작동해야하는지를 설명하는 것을 말합니다.
그리고 이 설명 방식을 Given-When-Then 구조라고 함

여기서 추상화라는 건 일상 생활에서 쓰는 언어에 가깝다는 것을 말합니다.
변태 개발자들이 괜히 추상화 수준이 높다 이런식으로 복잡하게 말하는데
그냥 사람이 알아듣기 쉬운 방식으로 말하면 추상화 수준이 높다고 말하는거임

Given : 시나리오에 필요한 모든 준비 과정
When : 시나리오 행동 진행
Then : 시나리오 진행에 대한 결과 명시, 증명

위 방식대로 테스트 코드를 작성하면
어떤 환경에서 ( Given )
어떤 행동을 진행했을 때 ( When )
어떤 상태 변화가 일어난다 ( Then )
-> DisplayName도 명확하게 작성할 수 있습니다.

이건 팁인데
인텔리제이 setting에서 검색창에
live templates를 입력하면
template을 등록할 수 있습니다.
여기에 test라는 템플릿을 등록하고

@DisplayName("")
@Test
void test() {
    // given

    // when

    // then

}

이 자동완성 되도록 등록해두면 편하니까 해놓으시면 편함.

[키워드 정리]

Spock이라는 테스트 프레임워크가 있습니다.
BDD 방식에 특화돼있음.

given, when, then을 주석으로 표시하지 않고
given :
when :
then :
이런식으로 작성함

JUnit과 비교해보면 어떨까요

언어가 사고를 제한한다는 말이 있죠
문서로서의 테스트 코드를 강조하는 이유기도 합니다.
잘 작동하는 테스트 코드라도 DisplayName 등이 명확하게 표현되지 않으면
문서로서 기능을 제대로 하지 못해서 오히려 사고를 제한할 수 있음요.


----------------------------------------------------------------------------------

